import "./Section2.css";
import Asciitable from "../Section1/ASCIITable/Asciitable";
import { useState } from "react";
import figure1 from "../../../../assets/figure1.png";
import figure2 from "../../../../assets/figure2.png";
import figure3 from "../../../../assets/figure3.png";
import figure4 from "../../../../assets/figure4.png";
import figure5 from "../../../../assets/figure5.png";
import figure6 from "../../../../assets/figure6.png";
import figure7 from "../../../../assets/figure7.png";
import figure8 from "../../../../assets/figure8.png";
import figure9 from "../../../../assets/figure9.png";
import figure10 from "../../../../assets/figure10.png";
import equation1 from "../../../../assets/equation1.png";
import equation2 from "../../../../assets/equation2.png";
import equation3 from "../../../../assets/equation3.png";
import equation4 from "../../../../assets/equation4.png";
import equation5 from "../../../../assets/equation5.png";
import equation6 from "../../../../assets/equation6.png";
import equation7 from "../../../../assets/equation7.png";
import equation8 from "../../../../assets/equation8.png";
import equation9 from "../../../../assets/equation9.png";
import equation10 from "../../../../assets/equation10.png";
import figure11 from "../../../../assets/figure11.png";
import figure12 from "../../../../assets/figure12.png";
import figure13 from "../../../../assets/figure13.png";

function Equation10() {
  const figStyle = {
    width: "200px",
    height: "250px",
  };
  return (
    <div className="section">
      <img src={equation10} alt="" style={figStyle} />
    </div>
  );
}
function Equation9() {
  const figStyle = {
    width: "270px",
    height: "70px",
  };
  return (
    <div className="section">
      <img src={equation9} alt="" style={figStyle} />
    </div>
  );
}

function Equation8() {
  const figStyle = {
    width: "350px",
    height: "100px",
  };
  return (
    <div className="section">
      <img src={equation8} alt="" style={figStyle} />
    </div>
  );
}
function Equation7() {
  const figStyle = {
    width: "150px",
    height: "75px",
  };
  return (
    <div className="section">
      <img src={equation7} alt="" style={figStyle} />
    </div>
  );
}
function Equation6() {
  const figStyle = {
    width: "150px",
    height: "75px",
  };
  return (
    <div className="section">
      <img src={equation6} alt="" style={figStyle} />
    </div>
  );
}
function Equation5() {
  const figStyle = {
    width: "200px",
    height: "100px",
  };
  return (
    <div className="section">
      <img src={equation5} alt="" style={figStyle} />
    </div>
  );
}
function Equation4() {
  const figStyle = {
    width: "400px",
    height: "350px",
  };
  return (
    <div className="section">
      <img src={equation4} alt="" style={figStyle} />
    </div>
  );
}

function Equation3() {
  const figStyle = {
    width: "600px",
    height: "130px",
  };
  return (
    <div className="section">
      <img src={equation3} alt="" style={figStyle} />
    </div>
  );
}
function Equation1() {
  const figStyle = {
    width: "550px",
    height: "60px",
  };
  return (
    <div className="section">
      <img src={equation1} alt="" style={figStyle} />
    </div>
  );
}

function Equation2() {
  const figStyle = {
    width: "550px",
    height: "60px",
  };
  return (
    <div className="section">
      <img src={equation2} alt="" style={figStyle} />
    </div>
  );
}

function Figure13() {
  const figStyle = {
    width: "444.077px",
    height: "305px",
  };
  return (
    <div className="section">
      <img src={figure13} alt="" style={figStyle} />
    </div>
  );
}
function Figure12() {
  const figStyle = {
    width: "417px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure12} alt="" style={figStyle} />
    </div>
  );
}
function Figure11() {
  const figStyle = {
    width: "417px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure11} alt="" style={figStyle} />
    </div>
  );
}
function Figure10() {
  const figStyle = {
    width: "417px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure10} alt="" style={figStyle} />
    </div>
  );
}

function Figure9() {
  const figStyle = {
    width: "350px",
    height: "130px",
  };
  return (
    <div className="section">
      <img src={figure9} alt="" style={figStyle} />
    </div>
  );
}
function Figure8() {
  const figStyle = {
    width: "350px",
    height: "130px",
  };
  return (
    <div className="section">
      <img src={figure8} alt="" style={figStyle} />
    </div>
  );
}
function Figure7() {
  const figStyle = {
    width: "550px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure7} alt="" style={figStyle} />
    </div>
  );
}

function Figure1() {
  const figStyle = {
    width: "550px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure1} alt="" style={figStyle} />
    </div>
  );
}

function Figure2() {
  const figStyle = {
    width: "550px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure2} alt="" style={figStyle} />
    </div>
  );
}

function Figure3() {
  const figStyle = {
    width: "350px",
    height: "350px",
  };
  return (
    <div className="section">
      <img src={figure3} alt="" style={figStyle} />
    </div>
  );
}

function Figure4() {
  const figStyle = {
    width: "550px",
    height: "250px",
  };
  return (
    <div className="section">
      <img src={figure4} alt="" style={figStyle} />
    </div>
  );
}

function Figure5() {
  const figStyle = {
    width: "600px",
    height: "200px",
  };
  return (
    <div className="section">
      <img src={figure5} alt="" style={figStyle} />
    </div>
  );
}

function Figure6() {
  const figStyle = {
    width: "350px",
    height: "150px",
  };
  return (
    <div className="section">
      <img src={figure6} alt="" style={figStyle} />
    </div>
  );
}

function Section2() {
  const [isTableVisible, setisTbleVisible] = useState(false);
  const handleOnShow = () => {
    setisTbleVisible(!isTableVisible);
  };
  return (
    <div className="section">
      <h1 className="heading">How SHA-256 Works</h1>
      <p className="h-para">
        A prominent cryptographic hash algorithm is SHA-256, a member of the
        SHA-2 family. It acts as a digital fingerprint for data, assuring its
        security and integrity. Let us examine how it works! üöÄ
      </p>
      <br />
      <h2 className="small-heading">Step 1 : Preprocessing the Message</h2>
      <p className="para">
        <b className="bold">üîç The Beginning of SHA-256:</b>
        The very first step in the SHA-256 journey is to convert plain text into
        binary format. But how do we know the binary values of each character?
        ü§î
      </p>
      <p className="para">
        <b className="bold">üìö ASCII to Binary Table:</b>
        To help us with this, we turn to an ASCII to binary table for reference.
        It's like having a secret codebook that tells us the binary code for
        every character we use. üìñüí°
        <br />
        In this way, we make sure our plain text is transformed into a language
        that SHA-256 can understand and work with - binary code! üí¨üî¢
      </p>
      <p className="para">
        Want to know binary values for your input!.
        <button onClick={handleOnShow}>
          {isTableVisible ? "Hide Table" : "=> Click Here"}
        </button>
      </p>
      {isTableVisible && <Asciitable />}
      <p className="para">
        As we embark on our learning journey, let us start with a simple example
        to help us understand the conversion of letters into binary code. In
        this example, we will look closer at the word "HELLO" and determine the
        binary values of each letter. We can understand how to convert letters
        into binary code by breaking down each letter into its binary
        equivalent.üßÆ
        <br />
        <br />
        üìù Now, we arrange these binary values in such a way that there are only
        32 bits in each row. Think of it as neatly organizing your belongings in
        different compartments. üì¶
        <br />
        üß© Here's how it looks:
      </p>
      <Figure1 />
      <br />
      <br />
      <h2 className="small-heading">Step 2: Padding the Message üìèüîó</h2>
      <p className="para">
        To ensure that SHA-256 can process a message accurately, it must pad the
        message to a sufficient length. Specifically, "the message needs to be a
        multiple of 512 bits, as required by SHA-256."[25]"
      </p>
      <h4 className="sub-heading">Why Padding?</h4>
      <p className="para">
        When we talk about padding in data transmission, it refers to adding
        extra bits to the message to make it the desired size. It's like adding
        blank pages to a book to increase its thickness. In the case of SHA-256,
        we add bits to the message to ensure that it meets the required size and
        can be transmitted efficiently.
      </p>
      <h4 className="sub-heading">How It's Done:</h4>
      <ol>
        <li>
          <h4 className="small-heading2">1. Start with a'1' Bit:</h4>
          <p>
            First, we add a single '1' bit to the end of the original message.
            This is like saying, "Okay, we're starting the padding now!"
          </p>
          <Figure2 />
        </li>

        <li>
          <h4 className="small-heading2">2. Add '0' Bits:</h4>
          <p className="para">
            Then, we insert several '0' bits (which serve as blank spaces). We
            continue to add '0's until the message is close to the size required
            by SHA-256.
          </p>
          <Figure3 />
        </li>
        <li>
          <h4 className="small-heading2">3. Stop Before 512-bit Boundary:</h4>
          <p className="para">
            We stop adding 0's when only enough storage is left for the message
            length (which takes up 64 bits). As a result, when the message
            reaches 448 bits (512 - 64 = 448), we stop padding. In above figure,
            all the zeros with aquatic blue represents 64 bits which are going
            to be used for message length process.
          </p>
        </li>
      </ol>
      <br />
      <br />
      <h2 className="small-heading">Step 3: Adding the Message Length üìèüî¢</h2>
      <p className="para">
        The purpose is to attach information about the original message's length
        to the end of the already padded message. This is analogous to including
        a note at the back of a letter indicating how long it is.
      </p>
      <br />
      <h4 className="small-heading2">How it's done</h4>
      <p className="para">
        <b className="bold-text">1. Calculate Length:</b>First, determine the
        length of your original message in bits.
      </p>
      <p className="para">
        <b className="bold-text">2. Convert Length to Binary:</b>Convert this
        length to a binary number next.But, SHA-256 needs this to be 64 bits
        long.
      </p>
      <p className="para">
        <b className="bold-text">3. Pad the Length to 64 Bits:</b>Add zeros to
        the beginning of this binary number until it reaches 64 bits.
      </p>
      <Figure4 />
      <p className="para">
        Next step is to divide total 512 bits in 16x32. Here we have to split
        512 blocks in 16 blocks of 32 bits. Each 32 bit representing a section
        of message.
      </p>
      <Figure7 />
      <br />
      <br />
      <h2 className="small-heading">
        üîÑ Step 4: Hash Computation Rounds (Compression Function) üöÄ
      </h2>
      <p className="para">
        Consider a treasure map with hints leading you closer to the hidden
        treasure. Step 4 in SHA-256 is akin to following those clues on an
        exciting journey searching for the ultimate treasure, the secure hash.
      </p>
      <p className="para">
        <b className="bold-text">1.Starting Point: </b>We begin with the 512-bit
        binary message, all ready and waiting for us. üìú
      </p>
      <p className="para">
        <b className="bold-text">2.Magic Constants:</b>
        Our trip is centred on eight secret constants (H0 to H7). These
        constants act as keys to concealed doors and are necessary for the
        mission.
      </p>
      <p className="para">
        <b className="bold-text">3.64 Rounds of Discovery: </b>
        Prepare to navigate a maze-like 64 rounds of twists and turns. In each
        round, we go through a variety of procedures.
      </p>
      <p className="para">
        Let us dive more deep into the working of SHA-256 algorithm
      </p>
      <br />
      <h4 className="sub-heading">
        Step 4.1 : Each message block M0, M2, M3...... M14 is processes in
        order, the following steps
      </h4>
      <p className="para">
        For i=1 to N: (N=1 because we have only one block of message at the
        moment.)
      </p>
      <Equation1 />
      <h4 className="bold-text">
        <b>
          1.Prepare Message Shedule for W<sub>t</sub>
        </b>
      </h4>
      <ul className="ml-4">
        <li>
          <p className="para">
            1.We have to preapre message shedule from W<sub>0</sub>, W
            <sub>1</sub> ....W<sub>63</sub>. Where each Wi is 32 bits in length.
          </p>
        </li>

        <li>
          <p className="para">
            For <b className="bold-text">Condition 1</b> in formula of Wt. It
            states that all the values we obtained from message prepration
            section. Which means all the 32 bits values of M<sub>0</sub>,M
            <sub>1</sub>,M<sub>2</sub>.....M<sub>15</sub>== W<sub>0</sub>,W
            <sub>1</sub>,W<sub>2</sub>...W<sub>15</sub>.
          </p>
        </li>
        <li>
          <p className="para">For example:</p>
          <Figure5 />
        </li>

        <li>
          <p className="para">
            For <b className="bold-text">Condition 2</b> in formula, explanation
            goes as follows: For W<sub>16</sub> till W<sub>63</sub> will use the
            following fomula:
          </p>
          <Equation2 />
        </li>
      </ul>
      <p className="para">
        Consider the following example, take a 32bit input and call it as "x".
        Where x is 32 bit long binary variable. <br />
        <b>x = [11001101 01101110 10110110 00110000]</b>
      </p>
      <h4 className="small-heading2">
        Very first let us try to understand and compute values of ùûÇ<sub>1</sub>{" "}
        and ùûÇ<sub>0</sub>. Begin with ùûÇ<sub>0</sub> as starting function of this
        formula.In ùûÇ<sub>0</sub> there are 3 stages for a Message M to get final
        output.
      </h4>
      <br />
      <br />
      <h3 className="small-heading2">
        Stage 1: First right rotation of 7 digits in x.
      </h3>
      <p className="para">
        For right-hand rotation, this means moving all bits of the binary value
        to the right by 'n' places. In this place, the integer is 7. The
        critical distinction between rotation and simple shift is that the bits
        shifted out on the right end do not disappear; instead, they reappear at
        the binary value's left end. For a 7-bit proper rotation, the 7 bits at
        the right end of the starting binary value are transferred to the
        beginning. <br />
        Example is mentioned as follows:
      </p>
      <Figure6 />
      <br />
      <h3 className="small-heading2">Stage 2: 18 circular right rotation</h3>
      <p className="para">
        For right-hand rotation, this means moving all bits of the binary value
        to the right by 'n' places. In this place, the integer is 18. <br />
        Example:
      </p>
      <Figure8 />
      <h3 className="small-heading2">Stage 3: Right shift of 3</h3>
      <p className="para">
        A digit shift operation is expected to shift each digit by a certain
        number of jumps. In this case, we will be moving each digit by three
        jumps. It's important to note that this is not a rotation, so the last
        three bits will be pushed out of the array. Here, we will shift each
        digit by three jumps. And because this is a shift and not a rotation,
        the last 3 bits will be pushed out of an array. <br /> Example
      </p>
      <Figure9 />
      <p className="para">
        <b className="bold-text">Final stage:</b>In this stage we are going to
        do bitwise addition of{" "}
        <b className="bold-text">Stage 1, Stage 2 and Stage 3</b>.The output
        should be 32 bits hence the addition will be bitwise addition modulo 2.{" "}
        <br />
        The bitwise addition modulo two operations, commonly known as the
        bitwise XOR operation, demands that each bit location in the 32-bit
        values be compared. If the bits of the operands differ, the resulting
        bit is set to 1; it is set to 0. This technique helps do logical
        operations on binary data. <br />
        Output of this addition will be "11010101 10111011 00111000 11110001"
        This finish ùûÇ<sub>0</sub> function's calculations.
      </p>
      <h4 className="small-heading2">
        Proceeding to next step where we find values of "ùûÇ<sub>1</sub> "
      </h4>
      <p className="para">
        ùûÇ<sub>1</sub> has same steps as we saw in ùûÇ<sub>0</sub>. but there is
        difference only in number of rounds in each stage. Here First right hand
        circular rotation has 10 shifts in bits, stage 2 has 19 right hand
        circular rotations in bits. And in stage 3, it has 10 right shifts
        without rotation.
      </p>
      <Figure10 />
      <p className="para">
        Now that we have computer both ùûÇ<sub>0</sub> and ùûÇ<sub>1</sub> and
        prepared a output. Let us continue our process from formula. Now as we
        have to find value of W<sub>16</sub>... to W<sub>63</sub>. Let use dive
        deep one block encryption. Lets start with our value t=16 because we
        already have values of W<sub>0</sub> to W<sub>15</sub>.
      </p>
      <Equation3 />
      <p>
        W<sub>0</sub> , W<sub>1</sub>, W<sub>9</sub> and W<sub>14</sub> are
        already defined because it is substitution of M<sub>0</sub>, M
        <sub>1</sub>, M<sub>9</sub> and M<sub>14</sub> <br />
        Now, because we have all the values ready we can substitute them and do
        bitwise addition then we will get 32 bit value of W16. And we will
        iterate this process continuously until we get all 32 bit values for W16
        to W63.
      </p>
      <h4 className="small-heading">
        Step5: Setting Initial Hash Values in SHA-256 üóùÔ∏èüî¢
      </h4>
      <h4 className="small-heading2">The Purpose:</h4>
      <ul>
        <li>
          <b className="bold-text">Starting Point: </b>These values are the
          starting point for the hashing process. Just like you need the first
          brush stroke on a canvas to create a painting, SHA-256 needs these
          initial values to start creating the hash.
        </li>
      </ul>
      <h4 className="small-heading2">Where Do These Values Come From?</h4>
      <ul>
        <li>
          <b className="bold-text">Derived from Primes: </b>"The initial hash
          values are derived from the square roots of the first eight prime
          numbers. Think of prime numbers as the building blocks of mathematics,
          and we're using their properties to kickstart our hash." [25]
        </li>
      </ul>
      <h4 className="sub-heading">The First Eight Primes:</h4>
      <ul className="ml-2">
        <li>1. 2</li>
        <li>2. 3</li>
        <li>3. 5</li>
        <li>4. 7</li>
        <li>5. 11</li>
        <li>6. 13</li>
        <li>7. 17</li>
        <li>8. 19</li>
      </ul>
      <h4 className="sub-heading">How Are Values Generated?</h4>
      <div className="ml-2">
        <p className="para">
          <b className="bold-text">Square Roots:</b> Take the square roots of
          these eight primes.
        </p>
        <p className="para">
          <b className="bold-text">Fractional Part:</b>We want the fractional
          part of these square roots, not the whole integer. It's akin to
          looking at the intricate patterns in a small piece of a giant puzzle.
        </p>
        <p className="para">
          <b className="bold-text">Convert to Binary:</b>These fractional parts
          are then converted into binary form.
        </p>
        <p className="para">
          <b className="bold-text">First 32 Bits:</b>These binary numerals are
          only used up to the first 32 bits. This is similar to choosing the
          necessary ingredients from a recipe.
        </p>

        <h4 className="sub-heading">Example (Simplified):</h4>
        <p className="para ml-2">
          Consider the number 2 and find its square root, approximately
          1.41421356. Our focus is on 0.41421356, which is the fractional part.
          To convert this fraction into binary, we need to follow a detailed
          process of repeatedly multiplying the fraction by two and taking the
          integer part. Suppose the binary result is 11001001... (and so on). We
          will only take the first 32 bits of the binary result for our
          purposes.
        </p>

        <h4 className="sub-heading">The Result:</h4>
        <ol className="ml-4">
          <li>
            You end up with eight 32-bit numbers. These are your initial hash
            values.
          </li>
          <li>They are the seeds from which the final hash will grow. üå±</li>
        </ol>
      </div>
      <h3 className="small-heading">
        Here are all the inital hash values in hexadeciaml format:
      </h3>
      <h4 className="sub-heading">
        H1<sup>(0)</sup> = bb67ae85 <br />
        H2<sup>(0)</sup> = 3c6ef372 <br />
        H3<sup>(0)</sup> = a54ff53a <br />
        H4<sup>(0)</sup> = 510e527f <br />
        H5<sup>(0)</sup> = 9b05688c <br />
        H6<sup>(0)</sup> = 1f83d9ab <br />
        H7<sup>(0)</sup> = 5be0cd19 <br />
      </h4>
      <br />
      <br />
      <h4 className="sub-heading">
        Step 5.1: Now assign these values from alphabet a to h according and
        later for computation purpose we will also need their binary 32 bit
        values.
      </h4>
      <h4 className="small-heading">
        a = H<sub>0</sub> = 6a09e667 = [01101010000010011110011001100111] <br />
        b = H<sub>1</sub> = bb67ae85 = [10111011011001111010111010000101] <br />
        c = H<sub>2</sub> = 3c6ef372 = [00111100011011101111001101110010] <br />
        d = H<sub>3</sub> = a54ff53a = [10100101010011111111010100111010] <br />
        e = H<sub>4</sub> = 510e527f = [01010001000011100101001001111111] <br />
        f = H<sub>5</sub> = 9b05688c = [10011011000001010110100010001100] <br />
        g = H<sub>6</sub> = 1f83d9ab = [00011111100000111101100110101011] <br />
        h = H<sub>7</sub> = 5be0cd19 = [01011011111000001100110100011001] <br />
      </h4>
      <br />
      <br />
      <h3 className="small-heading">Step 6: For loop</h3>
      <p className="para">
        We will now iterate from t= 1 till t = 63. For now we are going for t=1.
        To generalize the overall computation in this for loop. Let us take a
        quick look on it. For t = 0 to 63:
      </p>
      <Equation4 />
      <p className="para">
        Let us dive dep into these formulas and know more about them in detail.
        Starting with T1 and T2, We will first compute these two:
      </p>
      <br />
      <Equation5 />
      <p className="para">
        Starting with this function, it takes e as input as perform computations
        on it. The computation are in 4 stages as follows:
      </p>
      <Equation6 />
      <p className="para">
        <b className="bold-text">Stage 1:</b>Very similarly to what we saw in Wt
        calculations. At this stage we preform right shift circular rotation for
        2 bits. This rotation is applied on "e" which have already received.
      </p>
      <p className="para">
        <b className="bold-text">Stage 2:</b>In this stage, we will compute
        right shift circular rotation on "e". The shift will be of 13 bits in
        this stage.
      </p>
      <p className="para">
        <b className="bold-text">Stage 3:</b>In this stage, right shift circular
        rotation will be applied on "e". It will do 22 bits shifts.
      </p>
      <p className="para">
        <b className="bold-text">Stage 4:</b>In this stage, we will perform
        bitwise addition for{" "}
        <b className="bold-text">Stage 1, Stage 2 and Stage 3</b>. This will
        generate a 32 bit binary array as output.
      </p>
      <p className="para">
        Next, we have a function will very similarly working and computation of
        bits. But the only difference is number of bits shifted in each round.
      </p>
      <Equation7 />
      <p className="para">
        <b className="bold-text">Stage 1:</b>Again, very similarly to what we
        saw in Wt calculations. At this stage we preform right shift circular
        rotation for 6 bits. This rotation is applied on "e" which have already
        received.
      </p>
      <p className="para">
        <b className="bold-text">Stage 2:</b>In this stage, we will compute
        right shift circular rotation on "e". The shift will be of 11 bits in
        this stage.
      </p>
      <p className="para">
        <b className="bold-text">Stage 3:</b>In this stage, right shift circular
        rotation will be applied on "e". It will do 25 bits shifts.
      </p>
      <p className="para">
        <b className="bold-text">Stage 4:</b>In this stage, we will perform
        bitwise addition for{" "}
        <b className="bold-text">Stage 1, Stage 2 and Stage 3</b>. This will
        generate a 32 bit binary array as output.
      </p>
      <p className="para">
        Coming next is yet another function "Ch(e,f,g)" which sort for "choose".
        This function accept 3 inputs whoch are e, f and g 32 bits binary form.
        The purpose of Ch() is to mix the bits of e,f and g. The function will
        check each bit in e and every bit it check does following instructions:
        If (0 in e) then it will select a bit from g. Where the bit should be on
        same iteration i.e corresponding bit. If (1 in e) then the function will
        select one bit from f. The bit should be corresponding to current
        iteration in e. Below figure shows demonstration of this working.
      </p>
      <Figure11 />
      <p className="para">
        After performing these conditions for all 32 bits, this will return
        output if this function.
      </p>
      <h4 className="sub-heading">
        A quick mention about constants used in SHA-224 and SHA-256 (K)
      </h4>
      <p className="para">
        These constant are simply values of first 32 bits of fractional part of
        the cube roots of first 64 prime numbers. These values goes from K1, K2,
        K3...... up until K64.
      </p>
      <p className="para">
        428a2f98 71374491 b5c0fbcf e9b5dba5 3956c25b 59f111f1 923f82a4 ablc5ed5
        d807aa98 12835b01 243185be 550c7dc3 72be5d74 80deblfe 9bdc06a7 c19bf174
        e49b69c1 efbe4786 0fc19dc6 240calcc 2de92c6f 4a7484aa 5cb0a9dc 76f988da
        983e5152 a831c66d b00327c8 bf597fc7 c6e00bf3 d5a79147 06ca6351 14292967
        27b70a85 2e1b2138 4d2c6dfc 53380d13 650a7354 766a0abb 81c2c92e 92722c85
        a2bfe8al a81a664b c24b8b70 c76c51a3 d192e819 d6990624 f40e3585 106aa070
        19a4c116 le376c08 2748774c 34b0bcb5 391c0cb3 4ed8aa4a 5b9cca4f 682e6ff3
        748f82ee 78a5636f 84c87814 8cc70208 90befffa a4506ceb bef9a3f7 c67178f2
      </p>
      <p className="small-heading">
        Now as we all the values we need to compute T1, so we will now perform
        bitwise addition of 2 modulo 32
      </p>
      <Equation8 />
      <p className="para">
        Let us Now calculate another formula mentioned in this step:
      </p>
      <Equation9 />
      <p className="para">
        Breaking down this formula, we already know to calculate E and now let
        us evaluate the function Malj(a,b,c) Maj is short for "Majority". This
        function takes 3 inputs a, b and c. Then the function will iterate
        through all 32 bits of each variable. Comparing i th term from each a, b
        and c. It will check the majority in bit. Example: if a = 1, b = 0 and c
        = 1 for 1st bit then this function will finalise 1 as appropriate bit
        for output.
      </p>
      <Figure12 />
      <p className="para">
        With this function computed, we have all 32 bits values we need to put
        into T2 and compute it. Hence T2 is also evaluation is finished. <br />{" "}
        Now, most of the calculations part is finished and now what remains are
        just substitution and bitwise addition of two 32 bits arrays. These are
        the steps:
      </p>
      <Equation10 />
      <p className="para">
        After we run through this for loop, we will have all the new values for
        a,b,c,d,e,f,g and h in the form of 32 bit binary outputs. Next step, we
        will do bitwise addition (adding 32 bit binary values of both) to all
        these values obtained with inital Hash H values. We are doing this to
        update all the H values. It goes as follows:
      </p>
      <h3 className="sub-heading">H0 = a + H0</h3> <br />
      <h3 className="sub-heading">H1 = b + H1</h3> <br />
      <h3 className="sub-heading">H2 = c + H2</h3> <br />
      <h3 className="sub-heading">H3 = d + H3</h3> <br />
      <h3 className="sub-heading">H4 = e + H4</h3> <br />
      <h3 className="sub-heading">H5 = f + H5</h3> <br />
      <h3 className="sub-heading">H6 = g + H6</h3> <br />
      <h3 className="sub-heading">H7 = h + H7</h3> <br />
      <p className="para">
        Once we are done with updating our H's values we will get 8 sequence of
        32 bit numbers. We now will merge them together to form one 256 bit
        binary output. And here because we have N = 1 there is only 1 iteration
        in outerloop.
      </p>
      <h3 className="sub-heading">
        || H0 || H1 || H2 || H3 || H4 || H5 || H6 || H7 ||
      </h3>
      <p className="para">
        Finally, a last step to receive a final output, we will take this 256
        bit output and then make it binary to hexadecimal format. Which will
        generate our final intended output of this whole process.
      </p>
      <p className="para">
        Here is complete for loop demonstration in diagram format, this diagram
        represent all the calculation took place in above demonstration. This is
        total computation done in one round.:
      </p>
      <Figure13 />
    </div>
  );
}

export default Section2;
